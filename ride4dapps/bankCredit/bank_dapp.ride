# Bank credit dApp
# We assume that customer account have some value by itself.
# E.g.: it is tied to his passport or owning an account provides ownership of some real world thing or customer completed KYC via this account etc.
#
# 1. Bank approves credit for some address via 'approveCredit' function. It defines client address, amount of money,
# target height to return and account script for client.
# 2. Customer sets script for his account.
# 3. Customer can get money if he provides proof, that script was indeed set on his account
# 4. Customer can cancel credit contract via 'cancelCredit' if he didn't take the money
# 5. Customer can return money via 'returnMoney' function

# Simplifications for this version:
# a) This version does not account interest, but it can be easily added via additional argument to 'approveCredit'
# b) This version does not separate different credit contracts for one account. For now it is possible to have only one.
#    Having multiple contracts can also be implemented with contract id's

# Account lock script:
# Customer sets account script, which forbids setting another account script. After target height script
# forbids any operations other than calling dApp functions. If contract status is in ["returned", "canceled"], script allows to unset itself

{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

@Callable(i)
func approveCredit(client: String, amount: Int, target: Int, lockHash: ByteVector) = {
    if (this == i.caller && !isDefined(getBoolean(this, client + "_status"))) then {
        WriteSet([
            DataEntry(client + "_status", "approved"),
            DataEntry(client + "_amount", amount),
            DataEntry(client + "_target", target),
            DataEntry(client + "_lockScript", lockHash)
        ])
    }else {
        throw("Credit for " + client + " has already been approved or caller is not dApp owner")
    }

}

@Callable(i)
func getMoney(txId: String) = {

    let callerStr = toBase58String(i.caller.bytes)

    let status = match( this.getString(callerStr + "_status")){
        case x: Unit => "unset"
        case x: String => x
    }

    let lockTx = transactionById(fromBase58String(txId))

    let isLockSet = match (lockTx) {
        case t: SetScriptTransaction => t.sender == i.caller && t.script == this.getBinary(callerStr + "_lockScript").extract()
        case _ => throw("Lock has not been set")
    }

    let amount = this.getInteger(callerStr + "_amount").extract()

    if (status == "approved" && isLockSet) then {
        ScriptResult(
            WriteSet([
                DataEntry(callerStr + "_status", "borrowed")
            ]),
            TransferSet([ScriptTransfer(i.caller, amount, unit)])
        )
    }else throw("Credit was not approved or money has already been taken")

}

@Callable(i)
func returnMoney() = {
    let callerStr = toBase58String(i.caller.bytes)
    let status = match( this.getString(callerStr + "_status")){
        case x: Unit => "unset"
        case x: String => x
    }

    let pmt = extract(i.payment)

    let amountToReturn = getInteger(this, callerStr + "_amount")
    if(status != "borrowed") then throw("Cannot return, nothing was borrowed")
    else if (isDefined(pmt.assetId)) then throw("Can return only WAVES at the moment")
    else if (amountToReturn != pmt.amount) then throw("Should return borrowed amount")
    else {
        WriteSet([
            DataEntry(callerStr + "_status", "returned")
        ])
    }
}

@Callable(i)
func cancelContract() = {
    let callerStr = toBase58String(i.caller.bytes)
    let status = match( this.getString(callerStr + "_status")){
        case x: Unit => "unset"
        case x: String => x
    }
    if(status == "approved" || status == "unset") then WriteSet([DataEntry(callerStr + "_status", "canceled")])
    else {throw("Cannot cancel credit. Money has already been taken")}
}

@Verifier(tx)
func verify() = {
    match(tx) {
        case t:DataTransaction => false
        case t:SetScriptTransaction => false
        case _ => sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)
    }
}
